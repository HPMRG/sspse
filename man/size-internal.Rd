\name{size-internal}
\title{Internal size Objects}
% terms
\alias{size.checkargs}
\alias{size.checkdirected}
\alias{size.checkdegeneracy}
\alias{size.checkbipartite}
%
\alias{ConstraintImplications}
\alias{InitConstraint.bd}
\alias{InitConstraint.degreedist}
\alias{InitConstraint.degrees}                  
\alias{InitConstraint.edges}
\alias{InitConstraint.hamming}
\alias{InitConstraint.indegreedist}
\alias{InitConstraint.outdegreedist}
\alias{InitConstraint.nodedegrees}
%
\alias{check.ErgmTerm}
\alias{assignvariables}
\alias{InitErgmTerm.absdiff}
\alias{InitErgmTerm.absdiffcat}
\alias{InitErgmTerm.altkstar}
\alias{InitErgmTerm.asymmetric}
\alias{InitErgmTerm.b1degree}   
\alias{InitErgmTerm.b2degree}
\alias{InitErgmTerm.b1star}
\alias{InitErgmTerm.cycle}
\alias{InitErgmTerm.edgecov}
\alias{InitErgmTerm.hamming}
\alias{InitErgmTerm.isolates}
\alias{InitErgmTerm.match}
\alias{InitErgmTerm.mutual}
\alias{InitErgmTerm.nodefactor}
\alias{InitErgmTerm.nodeifactor}
\alias{InitErgmTerm.nodematch}
\alias{InitErgmTerm.nodemix}
\alias{InitErgmTerm.nodeofactor}
\alias{check.ErgmTerm.summarystats}
\alias{size.getglobalstats}
\alias{get.InitErgm.fname}
\alias{updatemodel.ErgmTerm}
\alias{copy.named}
\alias{safeupdate.formula}
\alias{model.matrix.pen.glm}
\alias{zerowarnings}
\alias{extremewarnings}


%
\alias{InitErgm.absdiff}
\alias{InitErgm.absdiffcat}
\alias{InitErgm.b1concurrent}
\alias{InitErgm.b1factor}
\alias{InitErgm.b1degree}
\alias{InitErgm.altkstar}
\alias{InitErgm.b1star}
\alias{InitErgm.asymmetric}
\alias{InitErgm.balance}
\alias{InitErgm.bounded.degree}
\alias{InitErgm.bounded.idegree}
\alias{InitErgm.bounded.istar}
\alias{InitErgm.bounded.kstar}
\alias{InitErgm.bounded.odegree}
\alias{InitErgm.bounded.ostar}
\alias{InitErgm.bounded.triangle}
\alias{InitErgm.concurrent}
\alias{InitErgm.ctriple}
\alias{InitErgm.ctriad}
\alias{InitErgm.cycle}
\alias{InitErgm.degree}
\alias{InitErgm.density}
\alias{InitErgm.dsp}
\alias{InitErgm.dyadcov}
\alias{InitErgm.b2concurrent}
\alias{InitErgm.b2degree}
\alias{InitErgm.edgecov}
\alias{InitErgm.edges}
\alias{InitErgm.esp}
\alias{InitErgm.b2star}
\alias{InitErgm.b2factor}
\alias{InitErgm.gwb1degree}
\alias{InitErgm.gwdegree}
\alias{InitErgm.gwdsp}
\alias{InitErgm.gwb2degree}
\alias{InitErgm.gwesp}
\alias{InitErgm.gwidegree}
\alias{InitErgm.gwodegree}
\alias{InitErgm.hamming}
\alias{InitErgm.hammingmix.constant}
\alias{InitErgm.hammingmix}
\alias{InitErgm.idegree}
\alias{InitErgm.intransitive}
\alias{InitErgm.isolates}
\alias{InitErgm.istar}
\alias{InitErgm.kstar}
\alias{InitErgm.localtriangle}
\alias{InitErgm.m2star}
\alias{InitErgm.meandeg}
\alias{InitErgm.mutual}
\alias{InitErgm.nearsimmelian}
\alias{InitErgm.nodecov}
\alias{InitErgm.nodemain}
\alias{InitErgm.nodefactor}
\alias{InitErgm.nodeicov}
\alias{InitErgm.nodeifactor}
\alias{InitErgm.nodematch}
\alias{InitErgm.match}
\alias{InitErgm.nodemix}
\alias{InitErgm.mix}
\alias{InitErgm.nodeocov}
\alias{InitErgm.nodeofactor}
\alias{InitErgm.odegree}
\alias{InitErgm.ostar}
\alias{InitErgm.receiver}
\alias{InitErgm.sender}
\alias{InitErgm.simmelian}
\alias{InitErgm.simmelianties}
\alias{InitErgm.smalldiff}
\alias{InitErgm.sociality}
\alias{InitErgm.transitive}
\alias{InitErgm.triadcensus}
\alias{InitErgm.triadcensus.directedonly}
\alias{InitErgm.triangle}
\alias{InitErgm.triangles}
\alias{InitErgm.tripercent}
\alias{InitErgm.ttriple}
\alias{InitErgm.ttriad}
\alias{InitErgm.twopath}
%
\alias{InitMHP.CondDegree}
\alias{InitMHP.CondDegreeDist}
\alias{InitMHP.CondInDegreeDist}
\alias{InitMHP.CondOutDegreeDist}
\alias{InitMHP.ConstantEdges}
\alias{InitMHP.dissolution}
\alias{InitMHP.formation}
\alias{InitMHP.formationTNT}
\alias{InitMHP.HammingConstantEdges}
\alias{InitMHP.HammingTNT}
\alias{InitMHP.nobetweengroupties}
\alias{InitMHP.randomtoggle}
\alias{InitMHP.randomtoggleNonObserved}
\alias{InitMHP.TNT}
\alias{MHproposal}
\alias{MHproposal.character}
\alias{MHproposal.size}
\alias{MHproposal.formula}
\alias{MHproposal.MHproposal}
\alias{MHproposal.NULL}
\alias{MHproposals}
%
\alias{degreedistfactor}
\alias{drawcircle}
\alias{drawpie}
\alias{dspartnerdist}
\alias{size.compute.degeneracy}
\alias{size.curved}
\alias{size.curved.statsmatrix}
\alias{size.curved.update}
\alias{size.degenerate}
\alias{size.estimate}
\alias{size.estimate.only}
\alias{size.eta}
\alias{size.etagrad}
\alias{size.etagradmult}
\alias{size.etamap}
\alias{size.geodesicmatrix}
\alias{size.geodesicmatrix.edgelist}
\alias{size.geodesicmatrix.old}
\alias{size.geodist}
\alias{size.geodistdist}
\alias{size.geodistn}
\alias{size.getMCMCsample}
\alias{size.mcmcslave}
\alias{size.getnetwork}
\alias{size.independencemodel}
\alias{size.initialfit}
\alias{size.logisticdeviance}
\alias{size.logitreg}
\alias{size.mainfitloop}
\alias{size.marquardt}
\alias{size.marquardt2}
\alias{size.pl}
\alias{size.nodegeodesics}
\alias{size.pairgeodesic}
\alias{size.phase12}
\alias{size.raftery.diag}
\alias{size.revisetheta0}
\alias{size.rhs.formula} 
\alias{size.stocapprox}
\alias{size.t.summary}
\alias{espartnerdist}
\alias{get.node.attr}
\alias{is.size}
\alias{is.matrixnetwork}
\alias{llik.fun}
\alias{llik.fun.miss}
\alias{llik.fun2}
\alias{llik.fun3}
\alias{llik.grad}
\alias{llik.grad.miss}
\alias{llik.grad2}
\alias{llik.grad3}
\alias{llik.hessian}
\alias{llik.hessian.miss} 
\alias{llik.hessian2}
\alias{llik.info3}
\alias{llik.mcmcvar3}
\alias{mcmc.diagnostics.default}
\alias{midarrow}
\alias{newnw.extract}
\alias{plot.mcmc.size}
\alias{print.raftery.diag.size}
\alias{robust.inverse}
\alias{rspartnerdist}
\alias{set.mfrow}
\alias{traceplot.size}
\alias{twopathdist}
%
\alias{size.sufftoprob}
\alias{size.Cprepare}
\alias{size.getmodel}
\alias{size.getterms}
\alias{size.gettermnames}
\alias{size.mple}
\alias{size.statseval}
\alias{fulldistdist}
\alias{fullgcount}
\alias{statnet.edit}
%\alias{get.node.attr}
%\alias{geodist}
%\alias{has.loops}
%\alias{is.directed}
%\alias{is.hyper}
%\alias{lpz.dist}
%\alias{mahal}
%\alias{mlpY}
%\alias{mlpY.grad}
%\alias{mlpY0}
%\alias{mlpY0.grad}
%\alias{mlpYmdsZ}
%\alias{mlpYmdsZ.grad}
%\alias{mlpYnull}
%\alias{prepmahal}
%\alias{symmetrize}
%
\alias{size.MCMCse}
%\alias{size.latentplot}
%\alias{mlpY.grad.plot}
%\alias{mlpY.plot}
%\alias{mlpYmdsZ.grad.plot}
%\alias{mlpYmdsZ.plot}
\alias{size.MCMCacf}
\alias{size.pen.glm}
\alias{logistftest}
%
\alias{size.mainloop}
\alias{size.robmon}
%
\alias{InitMHP.TNT10}

% More to triage
\alias{HTestimator}
\alias{Zee}
\alias{akestN}
\alias{bbfsolve}
\alias{beginparallel}
\alias{bfsolve}
\alias{bins}
\alias{bnwnest}
\alias{cmp.compute.z}
\alias{cmp.mu}
\alias{cmp.natural}
\alias{control.size}
\alias{dcmp}
\alias{dcmp.mu}
\alias{dcomsize}
\alias{discretemle}
\alias{discretemleN}
\alias{discretemleNimpute}
\alias{discretemleimpute}
\alias{discretemleimputeindividual}
\alias{discretemlesearch}
\alias{dwarC}
\alias{endparallel}
\alias{getest}
\alias{getestC}
\alias{getestCstacked}
\alias{getincl}
\alias{getincl.raw}
\alias{getinclC}
\alias{getinclCstacked}
\alias{impute.size}
\alias{llhood}
\alias{llhoodf}
\alias{llhoodfR}
\alias{llhoodfeed}
\alias{llhoodinC}
\alias{llhoodinCs}
\alias{lllspps}
\alias{llspps}
\alias{looplower}
\alias{margposteriorsize}
\alias{margposteriorsize.origandgood}
\alias{margposteriorsizewar}
\alias{mleNest}
\alias{plot.size}
\alias{poscmp}
\alias{poscmpdisease}
\alias{posdis}
\alias{posnbinom}
\alias{pospln}
\alias{posplndisease}
\alias{posteriordisease.orig}
\alias{posteriornbinom}
\alias{ppspolya}
\alias{print.size}
\alias{priordis}
\alias{probtodist}
\alias{rcmp}
\alias{rcmp.lambda}
\alias{roundstoc}
\alias{size}
\alias{sppsestN}
\alias{sppssample}
\alias{sppssamplei}
\alias{summary.size}
\alias{unposN}
\alias{unposNwar}
\alias{unposf}

%
% These need to be documented!
%

\alias{as.directed}
\alias{as.edgelist}
\alias{size.degeneracy} % At least this needs to be documented in summary.size and/or mcmc.diagnostics.size
\alias{print.network.series}
\alias{summary.statsmatrix.size}
\alias{summary.network.series}
\alias{license.statnet}
\alias{license.statnet1}
\alias{statnetShowDoc}
\alias{statnetbrowseURL}
\alias{size.bounddeg}
\alias{is.invertible}
\alias{ostar2deg}
\alias{sufftoprob}
\alias{degreedist}
\alias{mixingmatrix}
\alias{print.mixingmatrix}
\alias{print.summary.size} 
\alias{Summary.size.future}

\description{
  Internal size functions.
}
%\usage{
%anova.size(object, \dots)
%}
\details{
  Most of these are not to be called by the user (or in some cases are just
  waiting for proper documentation to be written :).
}
%\arguments{
% \item{\dots}{further arguments passed to or used by methods.}
%}
\seealso{size, statnet-package}
\keyword{internal}
