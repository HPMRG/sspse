% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/beginendparallel.R
\docType{methods}
\name{beginparallel}
\alias{beginparallel}
\alias{endparallel}
\title{Parallel Processing in the \code{\link[=sspse-package]{sspse}} Package}
\usage{
beginparallel(parallel = 1, type = "PSOCK", seed = NULL,
  packagenames = c("sspse"), verbose = TRUE)
}
\arguments{
\item{parallel}{scale; Number of threads in which to run the sampling. 
Defaults to 1 (no parallelism).}

\item{type}{API to use for parallel processing. Supported values are \code{"MPI"} and
\code{"PSOCK"}. Defaults to using the \code{parallel} package with PSOCK clusters.}

\item{seed}{integer; random number integer seed.  Defaults to \code{NULL} to
use whatever the state of the random number generator is at the time of the}

\item{packagenames}{Names of packages in which load to get the package to run
functions in addition to those autodetected. This argument should not be
needed outside of very strange setups.}

\item{verbose}{logical; if this is \code{TRUE}, the program will print out
additional information.
call.}
}
\description{
As the estimation requires MCMC, \code{\link[=sspse-package]{sspse}} can take
advantage of multiple CPUs or CPU cores on the system on which it runs, as
well as computing clusters. It uses package \code{parallel} and \code{snow}
to facilitate this, and supports MPI cluster type and likely PSOCK.
}
\details{
The number of nodes used and the parallel API are controlled using the
\code{parallel} and \code{type} arguments.
}
\section{PSOCK clusters}{
 The \code{parallel} package is used with PSOCK
clusters by default, to utilize multiple cores on a system. The number of
cores on a system can be determined with the \code{detectCores} function.

This method works with the base installation of R on all platforms, and does
not require additional software.
}

\examples{

# Uses 2 SOCK clusters for MCMLE estimation
N0 <- 200
n <- 100
K <- 10

# Create probabilities for a Waring distribution 
# with scaling parameter 3 and mean 5, but truncated at K=10.
probs <- c(0.33333333,0.19047619,0.11904762,0.07936508,0.05555556,
           0.04040404,0.03030303,0.02331002,0.01831502,0.01465201)
probs <- probs / sum(probs)

#
# Create a sample
#
set.seed(1)
pop<-sample(1:K, size=N0, replace = TRUE, prob = probs)
s<-sample(pop, size=n, replace = FALSE, prob = pop)
 
# Here interval=1 so that it will run faster. It should be higher in a 
# real application.  
out <- posteriorsize(s=s,interval=1, burnin=50,parallel=2,parallel.type="PSOCK")
plot(out, HPD.level=0.9,data=pop[s])
summary(out, HPD.level=0.9)
# Let's look at some MCMC diagnostics
plot(out, HPD.level=0.9,mcmc=TRUE)
}
